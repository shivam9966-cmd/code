import os
import json

AZURE_OPENAI_API_KEY   = "XXX"   # your API key
AZURE_OPENAI_ENDPOINT  = "XXX"   # e.g., "https://your-resource.openai.azure.com/"
AZURE_OPENAI_API_VER   = "XXX"   # e.g., "2024-10-01-preview"

AZURE_LLM_DEPLOYMENT   = "XXX"   # your chat model deployment name
AZURE_EMB_DEPLOYMENT   = "XXX"   # your embedding model deployment name



from llama_index.llms.azure_openai import AzureOpenAI
from llama_index.embeddings.azure_openai import AzureOpenAIEmbedding
from llama_index.core import Settings

llm = AzureOpenAI(
    model=AZURE_LLM_DEPLOYMENT,
    deployment_name=AZURE_LLM_DEPLOYMENT,
    api_key=AZURE_OPENAI_API_KEY,
    azure_endpoint=AZURE_OPENAI_ENDPOINT,
    api_version=AZURE_OPENAI_API_VER,
    temperature=0.1,
)

embed_model = AzureOpenAIEmbedding(
    model=AZURE_EMB_DEPLOYMENT,
    deployment_name=AZURE_EMB_DEPLOYMENT,
    api_key=AZURE_OPENAI_API_KEY,
    azure_endpoint=AZURE_OPENAI_ENDPOINT,
    api_version=AZURE_OPENAI_API_VER,
)

Settings.llm = llm
Settings.embed_model = embed_model


def _parse_json_from_text(text: str) -> dict:
    """Extract clean JSON from LLM output."""
    # Remove ```json fences
    if "```" in text:
        start = text.find("```")
        end = text.rfind("```")
        fenced = text[start + 3:end].strip()
        if fenced.lower().startswith("json"):
            fenced = fenced[4:].strip()
        text = fenced

    # Extract outermost { ... }
    first = text.find("{")
    last = text.rfind("}")
    if first != -1 and last != -1 and last > first:
        text = text[first:last + 1]

    return json.loads(text)


def _generate_single_level_summary(level: str, level_data: dict) -> dict:
    """
    Call LLM for ONE category (Revenue / OPEX / EBITDA)
    using strict FP&A prompt.
    """

    prompt = f"""
You are an FP&A analytics expert.

You will be given JSON data for a specific financial category at the level: "{level}".  
The category will always be one of the following: **Revenue**, **OPEX**, or **EBITDA**.  
Summarize ONLY the given category.  

â— STRICT RULE:  
- If level = "Revenue": DO NOT mention OPEX or EBITDA anywhere.  
- If level = "OPEX": DO NOT mention Revenue or EBITDA anywhere.  
- If level = "EBITDA": DO NOT mention Revenue or OPEX anywhere.  

Your task is to produce a clean JSON summary containing:
1. **executive_summary** â†’ 4â€“6 short bullet points (max 20 words each).  
2. **usd_values** â†’ JSON listing key USD metrics extracted or calculated from the data  
3. **variance_percent** â†’ % change from first month to last month  
4. **top_drivers** â†’ bullet list  
5. **risks_and_opportunities** â†’ bullet list  
6. **areas_of_focus** â†’ 2â€“4 tactical FP&A recommendations  

Formatting rules:
- USE emojis only for:
  ðŸ“ˆ = increase  
  ðŸ“‰ = decrease  
  âš ï¸ = risk  
  â­ = positive  
- NO nested JSON inside fields  
- NO text outside JSON  
- Keep it FP&A-style, concise, analytical  

Return STRICTLY this JSON structure:

{{
  "level": "{level}",
  "executive_summary": ["...", "..."],
  }},
  "variance_percent": "...",
  "top_drivers": ["...", "..."],
  "risks_and_opportunities": ["...", "..."],
  "areas_of_focus": ["...", "..."]
}}

Here is the JSON data for this level:
{json.dumps(level_data, indent=2)}

Respond ONLY with the JSON object above.
"""

    # Retry logic
    last_error = None
    for attempt in range(2):  
        try:
            response = llm.complete(prompt)
            json_text = response.text
            parsed = _parse_json_from_text(json_text)
            parsed["level"] = level
            return parsed
        except Exception as e:
            last_error = e

    raise last_error


def generate_all_level_summaries(usecases: dict) -> dict:
    """
    Generate ONE JSON containing summaries for:
    - Revenue
    - OPEX
    - EBITDA
    
    Expected usecases structure:
    {
        "Revenue": {...},
        "OPEX": {...},
        "EBITDA": {...}
    }
    """

    summaries = {}

    for level in ["Revenue", "OPEX", "EBITDA"]:
        if level in usecases and usecases[level] is not None:
            summaries[level] = _generate_single_level_summary(level, usecases[level])

    return summaries
