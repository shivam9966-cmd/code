import os
import json

# ================== AZURE OPENAI CONFIG (REPLACE XXX) ==================
AZURE_OPENAI_API_KEY   = "XXX"   # your API key
AZURE_OPENAI_ENDPOINT  = "XXX"   # e.g., "https://your-resource.openai.azure.com/"
AZURE_OPENAI_API_VER   = "XXX"   # e.g., "2024-10-01-preview"

AZURE_LLM_DEPLOYMENT   = "XXX"   # your chat model deployment name
AZURE_EMB_DEPLOYMENT   = "XXX"   # your embedding model deployment name


# ================== LLAMAINDEX SETUP ==================
from llama_index.llms.azure_openai import AzureOpenAI
from llama_index.embeddings.azure_openai import AzureOpenAIEmbedding
from llama_index.core import Settings

llm = AzureOpenAI(
    model=AZURE_LLM_DEPLOYMENT,
    deployment_name=AZURE_LLM_DEPLOYMENT,
    api_key=AZURE_OPENAI_API_KEY,
    azure_endpoint=AZURE_OPENAI_ENDPOINT,
    api_version=AZURE_OPENAI_API_VER,
    temperature=0.1,
)

embed_model = AzureOpenAIEmbedding(
    model=AZURE_EMB_DEPLOYMENT,
    deployment_name=AZURE_EMB_DEPLOYMENT,
    api_key=AZURE_OPENAI_API_KEY,
    azure_endpoint=AZURE_OPENAI_ENDPOINT,
    api_version=AZURE_OPENAI_API_VER,
)

Settings.llm = llm
Settings.embed_model = embed_model


# ================== HELPERS ==================
def _parse_json_from_text(text: str) -> dict:
    """
    Safely extracts the JSON object from the LLM output.
    Handles ```json fences and trims extra text.
    """
    # Strip code fences if present
    if "```" in text:
        start = text.find("```")
        end = text.rfind("```")
        fenced = text[start + 3:end].strip()
        if fenced.lower().startswith("json"):
            fenced = fenced[4:].strip()
        text = fenced

    # Keep only outermost {...}
    first = text.find("{")
    last = text.rfind("}")
    if first != -1 and last != -1 and last > first:
        text = text[first:last + 1]

    return json.loads(text)


def _detect_level(usecases: dict) -> str:
    """
    Auto-detect whether this is Revenue, OPEX, or EBITDA data
    based on top-level keys.
    """
    keys_lower = [k.lower() for k in usecases.keys()]

    if any("revenue" in k for k in keys_lower):
        return "Revenue"
    if any("opex" in k or "operating_expense" in k for k in keys_lower):
        return "OPEX"
    if any("ebitda" in k for k in keys_lower):
        return "EBITDA"

    # Fallback (you can change this default if you want)
    return "Revenue"


# ================== MAIN FUNCTION ==================
def generate_business_summary(usecases: dict) -> dict:
    """
    Uses Azure OpenAI via LlamaIndex to generate a JSON FP&A summary
    for a single financial category (Revenue / OPEX / EBITDA),
    auto-detected from the usecases dict.
    """

    level = _detect_level(usecases)

    prompt = f"""
You are an FP&A analytics expert.

You will be given JSON data for a specific financial category at the level: "{level}".  
The category will always be one of the following: **Revenue**, **OPEX**, or **EBITDA**.  
Summarize ONLY the given category.  

‚ùó STRICT RULE:  
- If level = "Revenue": DO NOT mention OPEX or EBITDA anywhere.  
- If level = "OPEX": DO NOT mention Revenue or EBITDA anywhere.  
- If level = "EBITDA": DO NOT mention Revenue or OPEX anywhere.  

Your task is to produce a clean JSON summary containing:
1. **executive_summary** ‚Üí 4‚Äì6 short bullet points (max 20 words each).  
   - Describe trend over months  
   - Important increases / decreases  
   - Key drivers  
   - ONLY for the selected category  
2. **usd_values** ‚Üí JSON listing key USD metrics extracted or calculated from JSON input  
3. **variance_percent** ‚Üí percent change from first month to last month  
4. **top_drivers** ‚Üí list of bullet points describing primary drivers for ONLY this category  
5. **risks_and_opportunities** ‚Üí bullet points listing risks & opportunities  
6. **areas_of_focus** ‚Üí 2‚Äì4 tactical recommendations  

Formatting rules:
- USE emojis only for direction indicators:
  üìà = increase  
  üìâ = decrease  
  ‚ö†Ô∏è = risk  
  ‚≠ê = positive highlight  
- NO nested JSON inside fields.  
- NO commentary outside JSON.  
- Keep summary analytical, crisp, and FP&A-style.

Return the response STRICTLY in this JSON structure:

{{
  "level": "Revenue or OPEX or EBITDA",
  "executive_summary": ["...", "..."],
  "usd_values": {{
      "month_1": "...",
      "month_2": "...",
      "month_3": "..."
  }},
  "variance_percent": "...",
  "top_drivers": ["...", "..."],
  "risks_and_opportunities": ["...", "..."],
  "areas_of_focus": ["...", "..."]
}}

Here is the JSON data for this level:

{json.dumps(usecases, indent=2)}

Respond ONLY with the JSON object above. Do not add any explanation or text outside JSON.
"""

    # ---------- Call LLM with single retry on JSON parse failure ----------
    last_error = None
    for attempt in range(2):  # 1st try + 1 retry
        try:
            response = llm.complete(prompt)
            text = response.text
            result = _parse_json_from_text(text)
            # add detected level if model leaves it generic
            if "level" in result and result["level"] not in ["Revenue", "OPEX", "EBITDA"]:
                result["level"] = level
            elif "level" not in result:
                result["level"] = level
            return result
        except Exception as e:
            last_error = e

    # If both attempts failed, raise the last error
    raise last_error
