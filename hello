import os
import json

# ================== AZURE OPENAI CONFIG (REPLACE XXX) ==================
AZURE_OPENAI_API_KEY   = "XXX"   # your API key
AZURE_OPENAI_ENDPOINT  = "XXX"   # e.g., "https://your-resource.openai.azure.com/"
AZURE_OPENAI_API_VER   = "XXX"   # e.g., "2024-10-01-preview"

AZURE_LLM_DEPLOYMENT   = "XXX"   # your chat model deployment name
AZURE_EMB_DEPLOYMENT   = "XXX"   # your embedding model deployment name


# ================== LLAMAINDEX SETUP ==================
from llama_index.llms.azure_openai import AzureOpenAI
from llama_index.embeddings.azure_openai import AzureOpenAIEmbedding
from llama_index.core import Settings

llm = AzureOpenAI(
    model=AZURE_LLM_DEPLOYMENT,
    deployment_name=AZURE_LLM_DEPLOYMENT,
    api_key=AZURE_OPENAI_API_KEY,
    azure_endpoint=AZURE_OPENAI_ENDPOINT,
    api_version=AZURE_OPENAI_API_VER,
    temperature=0.1,
)

embed_model = AzureOpenAIEmbedding(
    model=AZURE_EMB_DEPLOYMENT,
    deployment_name=AZURE_EMB_DEPLOYMENT,
    api_key=AZURE_OPENAI_API_KEY,
    azure_endpoint=AZURE_OPENAI_ENDPOINT,
    api_version=AZURE_OPENAI_API_VER,
)

Settings.llm = llm
Settings.embed_model = embed_model


# ================== SAFE JSON PARSER ==================
def _parse_json_from_text(text: str) -> dict:
    """Extract clean JSON from LLM response."""
    # Remove ```json fences
    if "```" in text:
        start = text.find("```")
        end = text.rfind("```")
        fenced = text[start + 3:end].strip()
        if fenced.lower().startswith("json"):
            fenced = fenced[4:].strip()
        text = fenced

    # Get the outermost JSON object
    first = text.find("{")
    last = text.rfind("}")
    if first != -1 and last != -1 and last > first:
        text = text[first:last + 1]

    return json.loads(text)


# ================== SINGLE-LEVEL SUMMARY CALL ==================
def _generate_single_level_summary(level: str, level_data: dict) -> dict:
    """
    Call LLM for ONE category (Revenue / OPEX / EBITDA)
    using your FP&A prompt and return parsed JSON.
    """

    prompt = f"""
You are an FP&A analytics expert.

You will be given JSON data for a specific financial category at the level: "{level}".  
The category will always be one of the following: **Revenue**, **OPEX**, or **EBITDA**.  
Summarize ONLY the given category.  

â— STRICT RULE:  
- If level = "Revenue": DO NOT mention OPEX or EBITDA anywhere.  
- If level = "OPEX": DO NOT mention Revenue or EBITDA anywhere.  
- If level = "EBITDA": DO NOT mention Revenue or OPEX anywhere.  

Your task is to produce a clean JSON summary containing:
1. **executive_summary** â†’ 4â€“6 short bullet points (max 20 words each).  
   - Describe trend over months  
   - Important increases / decreases  
   - Key drivers  
   - ONLY for the selected category  
2. **usd_values** â†’ JSON listing key USD metrics extracted or calculated from JSON input  
3. **variance_percent** â†’ percent change from first month to last month  
4. **top_drivers** â†’ list of bullet points describing primary drivers for ONLY this category  
5. **risks_and_opportunities** â†’ bullet points listing risks & opportunities  
6. **areas_of_focus** â†’ 2â€“4 tactical recommendations  

Formatting rules:
- USE emojis only for direction indicators:
  ðŸ“ˆ = increase  
  ðŸ“‰ = decrease  
  âš ï¸ = risk  
  â­ = positive highlight  
- NO nested JSON inside fields.  
- NO commentary outside JSON.  
- Keep summary analytical, crisp, and FP&A-style.

Return the response STRICTLY in this JSON structure:

{{
  "level": "Revenue or OPEX or EBITDA",
  "executive_summary": ["...", "..."],
  "usd_values": {{
      "month_1": "...",
      "month_2": "...",
      "month_3": "..."
  }},
  "variance_percent": "...",
  "top_drivers": ["...", "..."],
  "risks_and_opportunities": ["...", "..."],
  "areas_of_focus": ["...", "..."]
}}

Here is the JSON data for this level:

{json.dumps(level_data, indent=2)}

Respond ONLY with the JSON object.
"""

    last_error = None
    for attempt in range(2):  # 1st try + 1 retry
        try:
            response = llm.complete(prompt)
            text = response.text
            result = _parse_json_from_text(text)

            # Ensure level field is set correctly
            result["level"] = level
            return result
        except Exception as e:
            last_error = e

    raise last_error


# ================== MASTER FUNCTION: ALL LEVELS ==================
def generate_all_level_summaries(usecases: dict) -> dict:
    """
    Generate summaries for Revenue, OPEX, and EBITDA (if present)
    from the `usecases` dict.

    Expected structure (like your screenshot):
    {
        "Revenue": { ... },
        "OPEX":    { ... },
        "EBITDA":  { ... }
    }

    Returns:
    {
        "Revenue": { ...summary json... },
        "OPEX":    { ...summary json... },
        "EBITDA":  { ...summary json... }
    }
    """

    results = {}

    for level in ["Revenue", "OPEX", "EBITDA"]:
        if level in usecases and usecases[level] is not None:
            level_data = usecases[level]
            results[level] = _generate_single_level_summary(level, level_data)

    return results








# usecases = { "Revenue": {...}, "OPEX": {...}, "EBITDA": {...} }

all_summaries = generate_all_level_summaries(usecases)
all_summaries




import json

with open("summary_revenue.json", "w") as f:
    json.dump(all_summaries.get("Revenue", {}), f, indent=2)

with open("summary_opex.json", "w") as f:
    json.dump(all_summaries.get("OPEX", {}), f, indent=2)

with open("summary_ebitda.json", "w") as f:
    json.dump(all_summaries.get("EBITDA", {}), f, indent=2)

