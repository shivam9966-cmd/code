import pandas as pd
import json
import calendar
from typing import Optional
from openai import AzureOpenAI

# ============================================================================
# 1. AZURE OPENAI CLIENT (FILL THESE 4 VALUES)
# ============================================================================
AZURE_OPENAI_ENDPOINT = "https://YOUR-RESOURCE-NAME.openai.azure.com"
AZURE_OPENAI_API_KEY = "YOUR_API_KEY"
AZURE_OPENAI_API_VERSION = "2024-02-15-preview"  # example
AZURE_DEPLOYMENT_NAME = "YOUR_DEPLOYMENT_NAME"   # e.g. "gpt-4o-mini"

client = AzureOpenAI(
    api_key=AZURE_OPENAI_API_KEY,
    api_version=AZURE_OPENAI_API_VERSION,
    azure_endpoint=AZURE_OPENAI_ENDPOINT,
)

# ============================================================================
# 2. DATA PREP HELPERS
# ============================================================================

def prepare_dataframe(df: pd.DataFrame, date_col: str = "DATE") -> pd.DataFrame:
    """
    Ensure DATE is datetime-like so .dt works.
    """
    df = df.copy()
    if date_col not in df.columns:
        raise ValueError(f"Expected date column '{date_col}' not found in dataframe. Columns: {df.columns.tolist()}")

    # Only convert if not already datetime
    if not pd.api.types.is_datetime64_any_dtype(df[date_col]):
        df[date_col] = pd.to_datetime(df[date_col], errors="coerce")

    return df


def compute_yoy_variance(current_value: float, prev_value: float) -> Optional[float]:
    """
    YoY % = (current - prev) / prev * 100.
    """
    if prev_value == 0 or pd.isna(prev_value):
        return None
    return round(((current_value - prev_value) / prev_value) * 100, 2)


def compute_contribution(
    df: pd.DataFrame,
    level_col: str,
    amount_col: str = "Amount",
    top_n: Optional[int] = None,
) -> dict:
    """
    Compute contribution % by level_col, optionally top_n.
    Returns dict: {level_value: percentage}
    """
    if df.empty:
        return {}

    contrib = (
        df.groupby(level_col)[amount_col]
        .sum()
        .sort_values(ascending=False)
    )

    if top_n is not None:
        contrib = contrib.head(top_n)

    total = contrib.sum()
    if total == 0:
        return {}

    percent = (contrib / total * 100).round(2).to_dict()
    # ensure keys are str, values are float
    return {str(k): float(v) for k, v in percent.items()}

# ============================================================================
# 3. CORE BUSINESS METRICS LOGIC
# ============================================================================

def compute_business_metrics(
    df: pd.DataFrame,
    year: str,       # e.g. "FY25"
    month: int,      # 1-12
    version: str,    # "L6" or "L7"
    scenario: str,   # "Actual", "Plan", etc.
    date_col: str = "DATE",
    year_col: str = "YEAR",
    scenario_col: str = "SCENARIO",
    amount_col: str = "Amount",
    bucket_col: str = "account_L5_Description",
) -> dict:
    """
    Returns metrics:
    {
      "Revenue": {...},
      "OPEX": {...},
      "EBITDA": {...},
      "meta": {...}
    }
    """

    df = prepare_dataframe(df, date_col=date_col)

    # which level column we use for contribution
    level_col = f"account_{version}_Description"
    if level_col not in df.columns:
        raise ValueError(f"Level column '{level_col}' not found in dataframe. Columns: {df.columns.tolist()}")

    # derive previous FY: "FY25" -> "FY24"
    try:
        fy_int = int(year.replace("FY", ""))
        prev_year = f"FY{fy_int - 1}"
    except Exception:
        raise ValueError(f"Year format must be like 'FY25'. Got: {year}")

    # ------------------------
    # FILTER CURRENT + PREVIOUS YEAR, SAME SCENARIO
    # ------------------------
    mask_current = (
        (df[year_col] == year)
        & (df[date_col].dt.month == month)
        & (df[scenario_col] == scenario)
    )
    mask_prev = (
        (df[year_col] == prev_year)
        & (df[date_col].dt.month == month)
        & (df[scenario_col] == scenario)
    )

    df_current = df[mask_current].copy()
    df_prev = df[mask_prev].copy()

    # ------------------------
    # KPI AMOUNTS (L5 bucket: Revenue / Operating Expenses)
    # ------------------------
    rev_curr = df_current[df_current[bucket_col] == "Revenue"][amount_col].sum()
    opex_curr = df_current[df_current[bucket_col] == "Operating Expenses"][amount_col].sum()
    ebitda_curr = rev_curr - opex_curr

    rev_prev = df_prev[df_prev[bucket_col] == "Revenue"][amount_col].sum()
    opex_prev = df_prev[df_prev[bucket_col] == "Operating Expenses"][amount_col].sum()
    ebitda_prev = rev_prev - opex_prev

    # ------------------------
    # YoY VARIANCE %
    # ------------------------
    rev_yoy = compute_yoy_variance(rev_curr, rev_prev)
    opex_yoy = compute_yoy_variance(opex_curr, opex_prev)
    ebitda_yoy = compute_yoy_variance(ebitda_curr, ebitda_prev)

    # ------------------------
    # CONTRIBUTIONS (by L6 or L7)
    # ------------------------
    # Revenue → ALL heads
    df_rev_lvl = df_current[df_current[bucket_col] == "Revenue"]
    rev_contrib = compute_contribution(
        df_rev_lvl,
        level_col=level_col,
        amount_col=amount_col,
        top_n=None
    )

    # OPEX → TOP 3 heads
    df_opex_lvl = df_current[df_current[bucket_col] == "Operating Expenses"]
    opex_contrib = compute_contribution(
        df_opex_lvl,
        level_col=level_col,
        amount_col=amount_col,
        top_n=3
    )

    metrics = {
        "Revenue": {
            "selected_amount": float(round(rev_curr, 2)),
            "variance_percent_yoy": rev_yoy,
            "contribution": rev_contrib,
        },
        "OPEX": {
            "selected_amount": float(round(opex_curr, 2)),
            "variance_percent_yoy": opex_yoy,
            "contribution": opex_contrib,
        },
        "EBITDA": {
            "selected_amount": float(round(ebitda_curr, 2)),
            "variance_percent_yoy": ebitda_yoy,
            "contribution": None,
        },
        "meta": {
            "year": year,
            "prev_year": prev_year,
            "month": month,
            "month_name": calendar.month_name[month],
            "version": version,
            "scenario": scenario,
        },
    }

    return metrics

# ============================================================================
# 4. GPT BUSINESS SUMMARY (PER KPI, BULLET POINTS)
# ============================================================================

def generate_llm_business_summary(metrics: dict) -> dict:
    """
    Takes metrics dict and returns business summary bullets per KPI.

    Output:
    {
      "Revenue": ["• ...", "• ..."],
      "OPEX": ["• ..."],
      "EBITDA": ["• ...", "• ..."]
    }
    """
    meta = metrics.get("meta", {})
    year = meta.get("year")
    prev_year = meta.get("prev_year")
    month_name = meta.get("month_name")
    version = meta.get("version")
    scenario = meta.get("scenario")

    prompt = f"""
You are a senior FP&A analyst.

Dashboard filters:
- Year: {year}
- Previous year: {prev_year}
- Month: {month_name}
- Scenario: {scenario}
- Version (hierarchy level): {version}

KPI metrics JSON:
{json.dumps(metrics, indent=2)}

For each of Revenue, OPEX, and EBITDA:
- Write 2–3 very crisp FP&A business insight bullets.
- Focus on:
  - Current period amount (selected_amount)
  - YoY variance_percent_yoy (direction: above, below, in line)
  - Key contribution heads (for Revenue & OPEX from 'contribution').
- Do NOT mention other KPIs inside a section (Revenue section shouldn’t talk about OPEX).
- Tone: concise, board-ready, no fluff.
- Avoid restating raw numbers too much; summarize trends and drivers.
- Output bullets as plain text starting with "• ".

Return STRICTLY a JSON in this structure:
{{
  "Revenue": ["bullet1", "bullet2"],
  "OPEX": ["bullet1", "bullet2"],
  "EBITDA": ["bullet1", "bullet2"]
}}
No other text.
"""

    response = client.chat.completions.create(
        model=AZURE_DEPLOYMENT_NAME,
        messages=[{"role": "user", "content": prompt}],
        temperature=0.2,
    )

    content = response.choices[0].message.content

    try:
        summary = json.loads(content)
    except json.JSONDecodeError:
        # if model returns something messy, fall back to raw text
        summary = {
            "Revenue": [content],
            "OPEX": [],
            "EBITDA": [],
        }

    return summary

# ============================================================================
# 5. MASTER FUNCTION: WHAT YOU CALL FROM BACKEND WHEN FILTERS CHANGE
# ============================================================================

def generate_full_business_summary(
    df: pd.DataFrame,
    year: str,      # e.g. "FY25"
    month: int,     # 1–12
    version: str,   # "L6" or "L7"
    scenario: str,  # "Actual", "Plan", etc.
) -> dict:
    """
    Main function to call when user changes filters in frontend.

    Returns:
    {
      "metrics": {...},    # numeric snapshot
      "narrative": {...}   # GPT bullets per KPI
    }
    """
    metrics = compute_business_metrics(
        df=df,
        year=year,
        month=month,
        version=version,
        scenario=scenario,
    )
    narrative = generate_llm_business_summary(metrics)
    return {"metrics": metrics, "narrative": narrative}














print(df["DATE"].head())
print(df["DATE"].dtype)

