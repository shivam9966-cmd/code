# ---------- Build all three datasets ----------
act_kpi  = prepare_fact(actual_df,   "ACTUALS")
plan_kpi = prepare_fact(plan_df,     "PLAN")
fcst_kpi = prepare_fact(forecast_df, "FORECAST")

# ---------- Combine them ----------
granular = (
    act_kpi
      .unionByName(plan_kpi, allowMissingColumns=True)
      .unionByName(fcst_kpi, allowMissingColumns=True)
)

# Confirm creation
print("âœ… Combined dataset created as 'granular'")
print("Total rows:", granular.count())











# Your final unioned frame from the rebuild step
df = granular   # change if you used a different variable name

expected = [
    "product_L3_Description","product_L4_Description","product_L5_Description",
    "product_L6_Description","product_L7_Description","product_L8_Description",
    "account_L5_Description","account_L6_Description","account_L7_Description",
    "CC_L1_Description","CC_L2_Description","CC_L3_Description","CC_L4_Description",
    "ACCOUNT","COSTCENTER","PRODUCTLINE","SCENARIO","VERSION","Amount","YEAR","QUARTER"
]

print("Total cols:", len(df.columns))
missing = [c for c in expected if c not in df.columns]
print("Missing (should be empty):", missing)

# Quick peek
df.select(*[c for c in expected if c in df.columns]).show(10, truncate=False)

















from pyspark.sql import Window, functions as F

ACCOUNT_COL = "ACCOUNT"  # change if your column is named differently
TARGET = 5000

acct_counts = (
    df.groupBy(ACCOUNT_COL).count()
      .orderBy(F.col("count").asc(), F.col(ACCOUNT_COL).asc())
)

w = Window.orderBy(F.col("count").asc(), F.col(ACCOUNT_COL).asc())
acct_counts = (acct_counts
    .withColumn("row_number", F.row_number().over(w))
    .withColumn("cumulative_sum", F.sum("count").over(w))
)

exceed = (acct_counts
    .filter(F.col("cumulative_sum") > TARGET)
    .orderBy("cumulative_sum")
    .select("row_number")
    .limit(1)
    .collect()
)

if exceed:
    rnum = exceed[0][0]
    to_keep = acct_counts.where((F.col("cumulative_sum") <= TARGET) | (F.col("row_number") == rnum)) \
                         .select(ACCOUNT_COL).distinct()
else:
    to_keep = acct_counts.select(ACCOUNT_COL).distinct()

subset = df.join(to_keep, on=ACCOUNT_COL, how="inner")
print("Rows included (incl. full last account):", f"{subset.count():,}")
